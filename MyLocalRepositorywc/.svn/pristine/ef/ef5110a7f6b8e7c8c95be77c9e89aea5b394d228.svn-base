/*
'*******************************************************************************
'  Project name: PIC16F876A & MAX7219 For 8x8 LED Display
'  Description:
'          Trough the current experiment we wish to succed the next task:
'          Display on 8x8 Led matrix, the alphabet. The sequence between letters,
'          will have one second delay.
'  Written by:
'          Mark &
'          Aureliu Raducu Macovei, 2011.
'  Test configuration:
'    MCU:                        PIC16F876A;
'    Test.Board:                 WB-106 Breadboard 2420 dots;
'    SW:                         MikroC PRO for PIC 2011 (version v4.60);
'  Configuration Word:
'    Oscillator:                 HS (8Mhz)on pins 9 and 10;
'    Watchdog Timer:             OFF;
'    Power up Timer:             OFF;
'    Browun Out Detect:          ON;
'    Low Voltage Program:        Disabled;
'    Data EE Read Protect:       OFF;
'    Flash Program Write:        Write Protection OFF;
'    Background Debug:           Disabled;
'    Code Protect:               OFF
'*******************************************************************************
 */

// For more space, we don't need byte 0 and byte 7.
// We have stripped them out, if/when we have a need and a bigger PIC,
// then we can put them back if we want.

// Here we define row values for each of the six columns corresponding to the
// Alphabet, from  A through Z.
unsigned const short Alphabet[156]={
        0x7f, 0x88, 0x88, 0x88, 0x88, 0x7f,  // A

        0xff, 0x91, 0x91, 0x91, 0x91, 0x6e,  // B
        0x7e, 0x81, 0x81, 0x81, 0x81, 0x42,  // C
        0xff, 0x81, 0x81, 0x81, 0x81, 0x7e,  // D
        0x81, 0xff, 0x91, 0x91, 0x91, 0x91,  // E
        0x81, 0xff, 0x91, 0x90, 0x90, 0x80,  // F
        0x7e, 0x81, 0x81, 0x89, 0x89, 0x4e,  // G
        0xff, 0x10, 0x10, 0x10, 0x10, 0xff,  // H
        0x00, 0x81, 0xff, 0xff, 0x81, 0x00,  // I
        0x06, 0x01, 0x81, 0xfe, 0x80, 0x00,  // J
        0x81, 0xff, 0x99, 0x24, 0xc3, 0x81,  // K
        0x81, 0xff, 0x81, 0x01, 0x01, 0x03,  // L
        0xff, 0x60, 0x18, 0x18, 0x60, 0xff,  // M
        0xff, 0x60, 0x10, 0x08, 0x06, 0xff,  // N
        0x7e, 0x81, 0x81, 0x81, 0x81, 0x7e,  // O
        0x81, 0xff, 0x89, 0x88, 0x88, 0x70,  // P
        0x7e, 0x81, 0x85, 0x89, 0x87, 0x7e,  // Q
        0xff, 0x98, 0x98, 0x94, 0x93, 0x61,  // R
        0x62, 0x91, 0x91, 0x91, 0x91, 0x4e,  // S
        0xc0, 0x81, 0xff, 0xff, 0x81, 0xc0,  // T
        0xfe, 0x01, 0x01, 0x01, 0x01, 0xfe,  // U
        0xfc, 0x02, 0x01, 0x01, 0x02, 0xfc,  // V
        0xff, 0x02, 0x04, 0x04, 0x02, 0xff,  // W
        0xc3, 0x24, 0x18, 0x18, 0x24, 0xc3,  // X
        0xc0, 0x20, 0x1f, 0x1f, 0x20, 0xc0,  // Y
        0xc3, 0x85, 0x89, 0x91, 0xa1, 0xc3,  // Z
};

unsigned const short Symbols[114]={
        0x00, 0x3c, 0x42, 0x81, 0x00, 0x00,   // (
        0x00, 0x00, 0x81, 0x42, 0x3c, 0x00,   // )
        0x00, 0x00, 0xff, 0x81, 0x00, 0x00,   // [
        0x00, 0x00, 0x81, 0xff, 0x00, 0x00,   // ]
        0x00, 0x18, 0xe7, 0x81, 0x00, 0x00,   // {
        0x00, 0x00, 0x81, 0xe7, 0x18, 0x00,   // }
        0x00, 0x18, 0x24, 0x42, 0x81, 0x00,   // <
        0x00, 0x81, 0x42, 0x24, 0x18, 0x00,   // >
        0x00, 0x03, 0x0c, 0x30, 0xc0, 0x00,   // /
        0x00, 0xc0, 0x30, 0x0c, 0x03, 0x00,   // \
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   //
        0x00, 0x00, 0xfd, 0xfd, 0x00, 0x00,   // !
        0x60, 0x80, 0x8d, 0x8d, 0x90, 0x60,   // ?
        0x42, 0x24, 0xff, 0xff, 0x24, 0x42,   // *
        0x24, 0xff, 0x24, 0x24, 0xff, 0x24,   // #
        0x62, 0x91, 0xff, 0xff, 0x91, 0x4e,   // $
        0x66, 0x99, 0x99, 0x66, 0x09, 0x00,   // &
        0x42, 0xa4, 0x48, 0x12, 0x25, 0x42,   // %
        0x20, 0x3f, 0x20, 0x20, 0x3e, 0x21,   // pi
};

// Serial 8x8 Matrix Display connections.
sbit Chip_Select at RA2_bit;
sbit Chip_Select_Direction at TRISA2_bit;
// End Serial 8x8 Matrix Display connections.

// Here we set the configuration of max7219.
void max7219_init1()
{
    Chip_Select = 0;       // SELECT MAX
    SPI1_write(0x09);      // BCD mode for digit decoding
    SPI1_write(0x00);
    Chip_Select = 1;       // DESELECT MAX

    Chip_Select = 0;       // SELECT MAX
    SPI1_write(0x0A);
    SPI1_write(0x0F);      // Segment luminosity intensity
    Chip_Select = 1;       // DESELECT MAX

    Chip_Select = 0;       // SELECT MAX
    SPI1_write(0x0B);
    SPI1_write(0x07);      // Display refresh
    Chip_Select = 1;       // DESELECT MAX

    Chip_Select = 0;       // SELECT MAX
    SPI1_write(0x0C);
    SPI1_write(0x01);      // Turn on the display
    Chip_Select = 1;       // DESELECT MAX

    Chip_Select = 0;       // SELECT MAX
    SPI1_write(0x00);
    SPI1_write(0xFF);      // No test
    Chip_Select = 1;       // DESELECT MAX
}

// This is write Byte function.
void Write_Byte(unsigned short myColumn, unsigned short myValue)
{
    Chip_Select = 0;       // select max7219.
    SPI1_write(myColumn);  // send myColumn value to max7219 (digit place).
    SPI1_write(myValue);   // send myValue value to max7219 (digit place).
    Chip_Select = 1;       // deselect max7219.
}

// This is clear matrix function.
void Clear_Matrix(void)
{
    unsigned short x;

    for(x=1;x<9;x++)
    {
        Write_Byte(x,0x00);
    }
}

void Write_Char(char myChar)
{
    unsigned short Column, Start_Byte;
    // We will use only uppercase characters, so we will start from 65
    // (look at the ascii chart), with an offset of 6, becouse we are using only 6
    // bytes for each character.

    // Clear the display first.
    Clear_Matrix();

    // The next line defines our byte, from which to start the array.
    Start_Byte = (myChar - 65) * 6;     // 65 represents the letter "A" in ASCII code.

    // We are using only columns from 2 through 7 for displaying the character.
    for(Column=2;Column<8;Column++)
    {
        Write_Byte(Column, Alphabet[Start_Byte++]);
    }
}

// This is write char function.
void Write_Symbol(char mysymbols)
{
    unsigned short Column1, Start_Byte1;
    // We will use only uppercase characters, so we will start from 65
    // (look at the ascii chart), with an offset of 6, becouse we are using only 6
    // bytes for each character.

    // Clear the display first.
    Clear_Matrix();

    // The next line defines our byte, from which to start the array.
    Start_Byte1 = (mysymbols-0) * 6 ;

    // We are using only columns from 2 through 7 for displaying the character.
    for(Column1=2;Column1<8;Column1++)
    {
        Write_Byte(Column1, Symbols[Start_Byte1++]);
    }
}

// Here we have the main function.
void main()
{
    unsigned int x,y;

    Chip_Select_Direction = 0;    // Set RA2 pin as output.
    SPI1_init();                  // Initialize SPI1 module.

    max7219_init1();              // initialize  max7219.

    do                            // infinite loop.
    {
        // You can write the characters this way, one at a time.

        /*
  Write_Char('R');
  Delay_ms(1000);
  Write_Char('A');
  Delay_ms(1000);
  Write_Char('D');
  Delay_ms(1000);
  Write_Char('U');
  Delay_ms(1000);
         */
        // or

        for(x=65;x<=90;x++)    // Increment with 1, from 65 until 90.
        {
            Write_Char(x);
            Delay_ms(1000);      // This is our delay, between two consecutive character.
        }

        Clear_Matrix();       // Clear the Matrix display;
        delay_ms(500);

        for(y=0;y<=18;y++)
        {
            Write_Symbol(y);     // This is our delay, between two consecutive character.
            Delay_ms(1000);
        }

    }while(1);            // do forever.
}
